建立空白网页：about:blank

学习js推荐：
犀牛书：JavaScript权威指南
望远镜：JavaScript高级程序设计(红皮)
微信公众号:前端大全
js1k——国际大赛--进阶，最简代码最高效果


js正课第一天：
1、什么是js
2、如何使用js——如何编写
3、如何调试js
4、***变量
5、***数据类型

三个"*"代表重点
x：表示任意数  str：表示字符串 num：表示数字
"[]"：表示里面的内容可以省略

一、什么是js：JavaScript的缩写
   前端三大语言：
   HTML：编写网页内容的语言
   CSS： 美化网页内容样式的语言
   JS：  编写交互程序的语言，运行于js解释器/引擎中
      -解释执行————逐行读取，先读到先执行，后读到后执行
   <!-- 交互：有用户操作，程序处理或响应，还有返回结果，这就是交互 -->
   js发展史：navigator
	  1955 LiveScript————像极了Java，但比Java简单-->JavaScript
		Java"write noce run anywhere"
	  1996 JavaScript 1.1生成后送于ECMA，他制定了一个标准：
             -*ECMASAcript标准-->定义了js语言的核心语法
                -Netscape-->遵照标准，实现了JavaScript语言
                -Microsoft-->遵照标准，实现了JScript语言
	     后来，为了方便编写，出现了以下标准：
	     -W3C：DOM标准-->专门操作网页内容的标准，是目前所有浏览器都兼容的标准
	     -BOM标准：专门操作浏览器窗口的编程接口
   js=ECMASAcript标准+DOM标准+BOM标准
   js学习：ECMASAcript标准(10天) DOM标准(3天) BOM标准(2天)

二、如何使用js：
   -如何运用:
      1、浏览器内置js引擎
      2、独立安装js引擎：nodejs
   -如何编写：四种方式
      1、直接在浏览器控制台(F12)中编写js脚本：--临时调试
         Console：控制台：专门编写和调试js程序的窗口
	 比如：console.log("hello world!");
	    "console"--特指控制台窗口
	    "."--"的"之意
	    "log"--console中提供的一个功能，功能是接受一个字符串，在控制台中输出该字符串
	    字符串：一串字符的集合，字符串必须用引号包裹，但单双引号都行，其中的字符不要求大小写
	    *程序中的关键字要区分大小写！*
	  多行程序：shift+Enter
	  上下方向键：切换已执行过的代码--避免重复写入
      2、在网页中编写js脚本程序：3处
         脚本程序：不需要预编译，边解释边执行的程序
	 1、<script>元素中：直接编写在<script>中的js程序，随网页加载过程解释执行
	    例如：document.write("Hello from &lt;script&gt;!");//当前网页的写入
	             //document 当前网页
	             //. 的
	             //write 写入-是在网页body元素中，不带换行，write中的字符串必须符合html语法，所以换行用<br/>
	 2、单独js文件保存js脚本：2步
	    1、创建.js文件，保存js脚本语言
	    2、<script src="url"></script>引入外部js文件
      3、元素的时间处理程序中编写————了解
	    不随网页加载过程之行，只有触发事件时才执行
	    例如：window.alert("Hello from onclick");
	             //window 当前窗口
		     //. 的
		     //alert 警告栏-弹出一个小窗口，显示其中字符串
      注意：console后面只能是log、documen后面只能是write、window后面只能是alert

三、如何调试js：
   -bug：程序中出现的一切错误
   -debug：发现错误，解决错误
   -js程序出错：希望的交互效果没有出来-->F12-->console
      -console:有错误信息-三部分：错误类型 错误的原因 出错位置链接
      -出错现象；出错位置同<script>下的程序：
		   出错前的程序正常执行，出错位置及其之后的程序不执行，其他<script>中的程序，不受影响

四、***变量
   -what：内存中储存一个数据的存储空间，再起个名字
   -when：程序中的数据都要先用变量保存，再处理
   1、如何使用变量：声明 赋值 取值
      -声明：在内存中创建一个新变量--->如何赋值：var 变量名
         对于仅声明未赋值的变量，默认值自动式undefined
         变量的命名：
	    -不能以数字开头
	    -不能用保留字
	    -*见名知意*
	    -驼峰命名：首字母小写，之后每个单词首字母大写-->如：backgroundColor listStyleType
      -赋值：讲一个数据存入变量中  --->如何赋值：变量名=值
         对已有值的变量赋新值，新值会覆盖旧值
         等号"="：专门表示将右边的值，存入左边的变量中保存
	 强烈建议：声明同时初始化：第一次给变量赋值-->如何声明同时初始化：var 变量名=值;
      -取值：从变量中取数据进行运算--->如何取值：在程序的任何位置，只要使用变量名就等效于直接使用变量储存的数据
      特殊情况：2种
        1、为一个从未声明过的变量赋值：不会出错，会自动创建同名的全局变量，在保存数据
	2、尝试从一个为声明过得变量中取值：会报错！出现ReferenceError（未找到或未定义）
   ***声明提前：在程序正式执行前，都会将所有var声明的变量提前到开始位置集中创建。***赋值留在原地***。
   2、常量：一旦声明并初始化后，值不可改变的量！
      when：一旦创建保存，不可擅自改变的量时
      how ：const 变量名=值  常量名要全大写  
      外加：1弧度=园弧长等于其半径的弧度   html5中只认弧度，不认角度

五、***数据类型：
   What：内存中储存不同数据的储存格式
      js中的数据类型：2大类
         1、原始类型：值保存在变量本地的数据类型--五种
	    -Number 专门保存数字的类型
	    -String 专门保存字符串的类型
	    -Boolean 专门保存真/假二选一的类型
	    -undefined 只有一个只undefined
	    -null 表示不知向任何地址
	 2、引用类型：值不保存在变量本地的数据类型，可通过地址引用
   -原始类型介绍：
      1、Number类型：专门保存数字的类型，不用引号
         When：要参与算数计算或比较大小的数据  比如：价钱  年龄
         所占空间：64位二进制数保存  64Bit=8bytes
         强调：数字所占空间和数值大小无关，所占数字都占8字节
            1GB=1024MB 1MB=1024KB 1KB=1024bytes 1byte=8Bit
         ***舍入误差：因为计算机中无法精确表示1/10，导致计算中产生的误差，这是不可避免的
            解决：按指定小数位数四舍五入：——n.toFixed(2);-->将n按2位小数四舍五入
      2、String类型：专门保存一串字符的序列，必须带引号
         When：保存文字时，或保存仅用于显示的数字时  比如：姓名 身份证号 手机号 QQ号
	 所占空间：js的程序内存中的字符都是用Unicode标识的
	    Unicode：对全球主要语言中的每个字符都编一个号
	       每个英文字母、标点：1字节
	       每个汉字：2字节
	       比如："Hello马里奥"  11111222=11个字节
	 ***字符串内容一旦创建，不可改变！想要改变只能创建新字符串，替换旧字符串
	    +:如果参与"+"运算的值中包含字符串类型数据则加法运算自动变为字符串的拼接！
      3、Boolean类型：只有两个值true/false。
         When：如果表示二选一的值时，就用Boolean类型

js第二天：
1、***数据类型装换
2、***运算符和表达式
一、***数据类型装换：
   -***凡是从页面上获得一切数据，都是字符串类型
   -***js是弱类型编程语言：三方面
      1、声明变量是，不用规定变量储存的类型
      2、赋值时，动态决定变量的数据类型，同一个变量，先后可以保存不同各类型的数据
      3、运算时，js会根据需要，动态转换数据的类型
   -转换方式：两种
      1、隐式转换：无需程序员干预，js自动完成的类型转换
         -加运算的转化：两句话
	    1、算数运算中，一切类型都隐式转为number类型，再计算
	    2、特列："+"加运算中，只要一方是字符串，两数据都转为字符串，且加运算变为字符串的拼接！
	 -表达式：有数据，变量和运算符组成的一个公式，每个表达式默认都从左向右两两计算。
	    *每个表达式有且仅有一个运算结果！*
	 -NaN:Not a Nunber-->说明运算中包含了无法转化为数字的值，不是数字的数字
	 -typeof(x):专门用于判断x的数据类型，返回数据类型名  列如：typeof(NaN);  输出值是：number
	 注意：程序中，想改变一个变量中的值，只有赋值"="才可以，所以隐式转换，仅影响表达式的运算结果，不影响变量中储存的实际值
      2、强制转换：程序员通过主动调用专门的函数，执行转换
         -任意类型想to String：有两种方法
	    1、var str=x.toString();  js中，一切数据都有toString方法
	    2、var str=String(x);-->等同于"var str=x.toString();"，只是写法不一样，这就是隐式转换的原型 何时使用：程序在需要时，自动调用--注意：这个方法null和undefined转不了(会报错)，因为这两个值没有包装类型
	    注意：x.toString()和x.valueOf的区别：x.toString()返回的一定是字符串类型，x.valueOf不一定是字符串类型，可能是值
	 -***任意类型想to Number：
	    1、任意类型to Number:var n=Number(x);-->隐式
	    2、String to Number: 2种：
		-var n=parseInt(str);
                  原理：从str开始位置逐个读取每个字符直到碰到第一个不是数字的字符时，停止读取同时自动忽略开头碰到的空格
                  比如：
		     var width="12px";
                     width+"2px"-->"12px2px"
                     Number(width)+Number("2px")-->NaN
                     parseInt(width)+parseInt("2px")
                     parseInt("12px")+parseInt("2px")
                              12               2    -->14
                     width=14+"px";
                     限制：以下不能转换
		        var money="$400"; NaN
                                 "34.56"; 34
       
		-var n=parseFloat(str); 原理和parseInt完全一致！
                   但是，parseFloat,只认第一个小数点
                   比如：parseFloat("34.56"); 34.56
                         parseFloat("34.56.78"); 34.56
		注意：Number(x) 与 parseInt(str)比较 比如：
		   Number("12px")-->NaN
                   parseInt("12px")-->12
                   得出：string to Number-->parseInt
           
                   Number(true)-->1
                   parseInt(String(true))
                   parseInt("true")-->NaN
                   得出：x to Number-->Number()
         -任意类型转为Boolean:一种
	    var bool=Boolean(x);-->隐式转换
	    注意：任意值，只有控制符串""(空字符) "NaN" "undefined" "null" "0"这五个值转为false，其他都转为true

二、***运算符合表达式：
   -程序：让计算机按照人的想法去执行任务
   -运算符：程序中模拟人的思维运算或判断的符号
   1、算数运算符：+ - * /  % ++ --
      -%运算：取余数 被除数/除数，不取商而是取除不尽的余数 例如：17%3-->17除以3，取余数  输出是:2
	 何时使用：2大用处
	    -判断奇偶数：n%2-->1 奇数 否则为偶数
	    -确保一个运算的结果，不超过某个最大值（除数）
      ++运算：将当前变量中的值递增1  比如：n++; -->等同于n=n+1;
	 何时使用：只要是对变量中的值递增1，且还存回变量中
	    3种情况
	      - ++单独使用：前++和后++一样，即n++和++n一样
	      - ++运算参与到其他表达式中：
		前++(++n):将n中的值+1，然后返回*新值*
		后++(n++):将n中的值+1，然后返回*旧值*
	      注意：运算从左往右算，注意表达式返回值是多少，变量值是多少
		例如：
		    var n=2
		    var r=n++ + ++n + n++;
		分析：
		    第一个：n++-->返回值：2  变量值：n=3
		    第一个：++n-->返回值：4  变量值：n=4
		    第一个：n++-->返回值：4  变量值：n=5
		    console.log(n);  输出n=5;
		    console.log(r);  输出r=10;

		    var n=2
		    var r=++n + n++ + ++n;
		分析：
		    第一个：++n-->返回值：3  变量值：n=3
		    第一个：n++-->返回值：3  变量值：n=4
		    第一个：++n-->返回值：5  变量值：n=5
		    console.log(n);  输出n=5;
		    console.log(r);  输出r=11;
      --运算：当前变量中的值递减1，算法与++运算一样
   2、关系运算：将两个值做比较：>  <  >=  <=  ==  !==
      关系运算中只能返回两个值之一：如果成立，返回true;否则返回false;
      注意：在关系运算中存在隐式转换，会将所有数据类型都转为number类型再做比较
      特殊情况：3种
	 1、两字符串作比较：依次PK每一位字符的Unicode编码，只要有一位字符分出大小就不再比较
	    例如："3">"10"-->true   "Smith">"Scott"-->true   "张东">"张无忌"-->false
	 2、NaN:NaN和任何数据做大小或等于比较永远返回false，NaN和任何数据(包括NaN)做不等于比较永远返回true
	    isNaN(num):专门判断num是否是NaN，如果是NaN返回true，否则返回false
	    When：只要判断一个数值是否是数字或能否被转为数字，都是用isNaN。如果是数字，返回false，否则返回true
	 3、undefined和null比较：undefined==null  输出true，这是不严格引起的，引出全等"==="
	    ===：全等--要求首先是数据类型要相同，在比较值是否相等，不带隐式转换
	    何时使用：只要不希望关系运算中自动隐式转换时就用
   3、***逻辑运算：综合多个关系运算的结果得出最终结论，返回值只能二选一：满足条件返回true，否则返回false
      隐式类型转换：自动将每个条件转为Boolean类型
      3种类型：
         -关系运算1&&关系运算2：而且--两个条件必须都是true，才返回true，否则返回false
         -关系运算1||关系运算2：或者--只要有一个条件为true，则返回true，只有两个条件都为false时，才返回false
         -！关系运算：颠倒关系运算的true/false结果
      ***短路逻辑：如果前一个条件已经可以得出结论，则后续条件不再执行！
      ***利用短路逻辑：2种：
         1. 利用&&的短路逻辑：关系运算&&操作：只有满足关系运算时，才执“操作”
         2. 利用||的短路逻辑：关系运算||操作：如果前一个条件不满足，才执行后一个"操作" 
      鄙视题：
         alert(4&&5);//? 5
         alert(4||5);//? 4
	 alert(null&&5);//? null
	 alert(null||5);//? 5
      作业：5_login.html：鄙视题 
      作业：逻辑运算：课堂练习：2个问题
         问题1：如何判断一个字符是汉字：
         第一个汉字"一"-->"\u4e00"
         最后一个汉字"\u9fa5"

   4. 位运算：2个
      左移：n<<m 将n的二进制，左移m位
         比如：1<<3  -->1*  2的3次方
      右移：n>>m 将n的二进制，右移m位
         比如：64>>3 -->64/ 2的3次方  ==> 8

   5. 扩展赋值运算：5个：+=  -=   *=  /=  %=
      仅讨论+=: n+=2; ==>n=n+2-->将n中的值+2后，再保存回n中
      何时使用：今后只要对变量中的值进行累加时，都要用扩展赋值运算。

   6. ***三目运算：根据不同的条件，多选*一*，返回不同的结果
      语法：条件1?值1:
         条件2?值2:
           ...?...:
             默认值;
      无论三目运算多么复杂，结果只能是一个值。
      例如：var max=a>b?"a":"b";

js第三天：
1、***函数
2、全局函数--了解
3、*分支结构

*** 表达式只要有输出值就可以当值用 ***

一、***函数：封装一个专门任务的 步骤清单 的代码段，再起一个任务名
   -函数其实是引用类型的对象;函数名其实是指向函数对象的变量;
   1、何时使用(when)：只要定义一个转么的任务，都要封装一个函数
   2、使用函数：声明 定义和定义
      -如何声明并定义一个函数：//function也是声明，只是声明的是一个函数
         function 函数名([参数变量列表]){
	    函数体：包含任务的步骤清单（代码段）
	    [return 返回值]
	 }
      -如何调用函数：[var 返回值=]函数名([参数值列表]);
         函数只有调用时才执行，可以反复调用，反复调用会执行相同操作
      -为什么定义函数：一次定义，反复使用（代码重用）！一次修改，处处生效（便于维护）。
      -函数的参数：专门接收传入函数内的数据的*变量*
         1、何时定义参数：如果一个函数必须某些数据才能正常执行时--参数可以让函数更加灵活
         2、如何定义参数变量：function 函数名(变量1，变量2，...)
            强调：一般值的个数和顺序，应与声明时的参数列表一致
      -返回值：函数调用后，返回的执行结果！---1个数据
         1、如何返回函数：在函数体中，return表示要返回的数据
         2、强调：return可以单独使用，表示退出函数执行的意思;函数仅负责返回数据，但不负责保存应返回的数据
      -如何获得返回值：调用时赋值：var 变量=函数名();
   3、***变量作用域：一个变量的可用范围
      -js中2中作用域：
         1、全局作用域：一个变量可以在程序的任何位置被访问
	 2、函数作用域：一个变量仅能在函数调用时内部被访问
      -js中2中变量：
         1、全局变量：定义在全局作用域中的变量-2种
	    -直接在任何函数外声明的变量--全局变量都属于全局对象(window)
	    -无论在任何位置，为从未声明过的变量赋值时会自动在全局创建同名全局变量！
	 2、局部变量：定义在函数作用域中的变量-2种
	    - 在函数定义内部声明的变量
            - 参数变量天生就是局部变量
   
   <!-- 今天的理解
      函数的定义和调用过程：
         1. 声明和定义函数时：
	   window中创建了函数名变量
           window外创建了函数定义的对象-->封装函数的定义
           函数名变量中保存了指向函数对象的地址
         2. 调用时，创建局部变量：2种
         3. 调用过程中，如果局部有，就不用全局的
                  如果局部没有，才会用全局的
                  如果全局也没有，则报错！
         4. 调用结束后，释放所有局部变量！ 
   -->

   4、*声明提前：在程序执行前或函数被调用前，将var声明的变量和function声明的函数提前到当前作用域的顶部集中创建
      强调：仅声明提前，赋值留在原地
   5、***按值传递：js中无论变量间赋值或使用变量传递参数时，都是将变量中的值，复制一个副本给对方！
   6、 全局函数——了解
      -什么是：*ES标准中*已经定义好的，开发者可直接调用的函数
         parseInt/Float(str)
         isNaN(num)
         alert(str)X
         prompt(str)X

      -编码/解码:
         编码：将url中的非法字符，改为合法字符表示 
	    http://..../s?word=%E5%BC%A0
                             张
                         utf-8格式编码
                           汉字占3字节
          url中不允许出现多字节字符！
          解决：将url中的多字节，变为单字节
          url中不允许参数值中出现保留字符：比如: /http://tmooc.cn -->http%3A%2f%2ftmooc
          解决：encodeURIComponent
      -解码：将url中的非法字符编码后的内容，恢复成原文
             decodeURIComponent
      eval: 计算字符串格式的表达式的值或执行字符串格式的js语句

      程序结构3大类：
         -顺序：程序默认都是从上向下逐行执行
	 -分支：根据条件判断的结果，有选择的执行不同代码
	 -循环：程序可以反复执行同一代码段，达到临界时退出
      结构共同需求：input-输入 process-处理 output-输出

   7、*分支结构：3种
      1、if结构：1件事 满足条件就执行，否则不执行
         语法：if(条件){满足条件才执行的代码}
	 注意：简单的话可以用短路代替，例如：a<b&&()
      2、if...else...结构：2件事 满足条件执行if中的代码段，不满足条件执行else中的代码段
         语法：if(条件){满足条件才执行的代码段}else{不满足条件才执行的代码段}
      3、else if结构：多事件，根据条件多选一执行
         语法：
	    if(条件1){
	       满足条件1才执行的代码段	
	    }else if(条件2){
	       满足条件2才执行的代码段	
	    }else if(条件3){
	       满足条件3才执行的代码段	
	    }[else{不满足之前任何条件才执行的代码段}]
      注意：如果程序已经引入后一个条件判断，就已经暗示前一个条件肯定不满足
      分支结构和三目/短路的比较：如果只是返回值--用三目/短路，如果操作复杂--用分支结构
      4、switch case结构：都是根据不同条件执行不同代码段，用switch中的表达式的值和case中的值做*全等*比较
         语法：
	    switch(表达式){
	       case 值1：代码段1;break;
	       case 值2：代码段2;break;
	       case 值3：代码段3;break;
	       ...         ...
	       [default：默认代码段;break;]
	    }
	    break:停止当前结构的执行，并跳出当前结构
     switch case与else if比较：条件是全等比较时，首选switch case，除全等条件比较外，希望灵活定义条件是用else if

js第四天：循环结构
/* 在任意min-max之间取随机整数的公式：parseInt(Math.random()*(max-min+1)+min) 0<=r<1*/
一、循环结构：让程序反复执行一段代码段，只有到达临界条件时才停止循环
   循环结构三要素：
      1、循环条件：继续循环的条件  比如：圈数<3
      2、循环变量：在循环条件中用作比较的变量，循环变量一般会向着不满足循环条件的趋势不断变化  比如：圈数，每圈加1
      3、循环体：返回执行的代码段
   循环结构分三种：
      1、while循环：
         语法：
	    var 循环条件=初始值;
	    while(循环条件){循环体;迭代变化循环变量(例如n++)}
      2、do while循环：
         语法
	    var 循环条件=初始值;
	    do{循环体;迭代变化循环变量;}while(循环条件);
	 while和do while差别：当第一次条件满足时，while和do while完全一样;当第一次条件不满足是，do while至少执行一次，while一次都不执行
	 何时使用do while代替while？只要希望哪怕第一次条件都不满足是，至少也能执行一次
	 /* js里面没有块级作用域，分支/循环结构中声明的变量，出了结构照样使用 */
      3、*for循环
         语法：
	    var 循环变量=初始值;
	    for(var 循环变量=初始值;循环变量;迭代变化循环变量){循环体;}
	 何时使用：只要循环变量的变化规律固定，优先选择for循环
      退出循环：两种
	 1、自动退出：不满足循环条件时，自动退出循环
	 2、手动退出：根据程序员在循环体中用break强行退出循环
	 continue：结束本轮循环，继续下轮循环，一般都可以用否定条件"!"代替，所以使用率不高
	 /* e是科学计数法：1e+10-->等于1乘以10的10次方 */

js第五天：
***数组***//数组中的[]不是可以省略之意，而是固定格式
   程序=数据结构+算法
	好的数据结构，可以极大提高程序的执行效率
	相关的多个数据应集中存储，集中管理--分类和排序
一、数组：一组连续的变量组成的集合---统一起一个名字，批量管理多个数据
   如何使用：创建    赋值     取值
    -创建：4种：
       1. var 变量名=[];-->创建一个空数组对象
       2. var 变量名=[值1,值2,...]-->创建数组同时，为数组指定初始元素(数组中每个值)
        数组是引用类型的对象
        变量中保存了数组对象的地址值，也成引用了数组对象
       3. var arr=new Array();-->创建一个空数组对象
         new：创建一个新对象，并返回新对象地址
         Array：js中的数组类型
         new Array()-->创建一个数组类型的新对象，并返回新对象的地址。
       4. var arr=new Array(n);-->创建n个元素的数组
                  new Array(值1,值2,...)

       -找到数组：使用变量等效于直接使用变量引用的数组对象
       -数组对象中，每个元素都有一个下标：每个元素的位置号
          下标从0开始，到元素个数-1结束
          使用数组中的每个元素：
	     数组变量[i]-->获得i位置元素中的值//[i]是数组的下标
             *数组变量[i]的用法和普通变量完全一样！*
    -赋值：数组变量[i]=新值;
    -取值: 数组变量[i]

    null和undefined:
      undefined: 是所有没有值得变量的默认值，自动赋值
      null: 主动释放一个变量引用的对象
        何时使用null：
	 当使用完一个较大的对象时，主动释放对象总是好的习惯

    垃圾回收器：专门释放对象内存的一个程序
                在底层，后台，伴随当前程序同时运行
                引擎会定时自动调用垃圾回收期
                总有一个对象不再被任何变量引用时，才释放

    js数组 vs 其他语言的数组：
    *js数组下标越界不会出错！*
      为不存在的位置赋值：不会出错！会自动创建指定下标的新元素。
      从不存在的位置取值：不会出错！也不会增加新元素，而是返回undefined
二、数组是对象：封装了一组数据，并提供了对数据的操作方法
   -.length属性：获得数组中的元素个数，但是它!=实际的元素个数
   -何时使用：三种
      1、arr[arr.length-1]:获得任意数组中的最后一个元素
      2、arr[arr.length]=新值：表示向数组末尾追加一个新元素
      3、改小.length的值，可删除末尾元素
三、数组遍历：从下标0位置开始，依次去输出每个元素，反复执行相同的操作，相当于一个循环
   三要数：
      1、循环条件：下标i<arr.length
      2、循环变量：下标i，从0开始，每次增1，到arr.lenght-1结束
      3、循环体：要求
四、关联数组：可以自己定义下标名称的数组
   如何创建关联数组：var fbb=[];
		      fbb["sname"]="范冰冰";
		      fbb["shx"]=91;
   如何访问关联数组中的元素:fbb["sname"]


五、***冒号排序
六、*数组API：数组=数据+操作数据的API
   -API的分类：API-应用程序编程接口，实际是应用已经实现的、现成的对象方法---提高开发效率
      1、数组to String：2种
         var str=arr.toString();-->输出数组中的内容，每个元素用逗号分隔，自动调用
	 var str=arr.join("连接符");-->输出数组中的内容，自定义元素中的连接符
	    -何时使用：2种固定套路
	       1、将字符组成单词：arr.join("")--其中括号中的空字符不能省略，不然会输出toString
	       2、将单词组成句子：arr.join(" ")--其中括号中输入的是一个空格
	    *优化：频繁的字符串拼接会浪费，造成内存拼接*
	       解决：先将要拼接的字符串放入数组，最后用arr.join("")进行拼接
      2、拼接和截取：*API无法直接修改原对象，而是返回新对象，没有接取的话新对象会被丢掉*
         -拼接：var newArr=arr.concat(另一个数组,值1,值2...)//这里面的值可以为数组，结果一样
	 -截取-赋值子数组：var subArr=arr.slice(starti(下标),[endi+1](下标));
	    1、第二个参数可以省略，如果省略表示从starti位开始截取到最后一位：
	    2、两个值都可以取负值(表示从后面开始数)，就近使用下标-注意：负数下标是从1开始，正数下标是从0开始的
	    3、含头不含尾,所以要结束+1，推到结束的后一位，这个属性是必须的，所以不管取正值负值都要

      3、 splice: 删除   插入    替换
	 1、 删除：直接修改原数组对象-[var deleted=]arr.splice(starti,删除个数);返回本次删除元素组成的数组
	 2、 插入：arr.splice(starti,0,新值1,...);
	 3、 替换：arr.splice(starti,删除个数,新值1,...);
      4、arr.reverse(); 颠倒数组中所有元素

js第六天：
1、***数组API
   ***数组排序   *栈和队列
2、*二维数组
3、***String

一、数组API：
   1、数组的排序：arr.sort();
      存在的问题：默认是将所有元素转为字符串升序排列
      解决：
         ***比较器：专门比较任意量值大小的函数
	 特点：
	 1、两个参数分别表示要比较的任意
	 2、无论比较逻辑是什么，都要返回一个数字
      -如何自定义sort方法的排序？ arr.sort(比较器函数)
      -*颠倒比较器结果的正负，可改升序为降序排列*
      ***函数对象作为参数：
         js中函数本质是一个对象
         函数名本质是指向函数对象的变量
        /* 
	   函数可以作为一个值给其他函数调用
	   -直接使用函数名(不带"小括号()") ，表示调用该函数计算值函数方法
	   -使用函数(带"小括号()")，表示调用该函数计算后得到的值
	   函数名后加()，表示立即执行！
	*/
   2、 *栈和队列：js中没有真正的栈和队列的类型，一切都是用数组对象模拟的
      -栈：只能从一端进出的数组，另一端封闭：FILO
         何时使用：今后只要仅希望数组只能从一端进出时
         如何使用：2种情况：
            1、末尾出入栈：已入栈元素的下标不再改变
               -入栈: arr.push(新值1,...)
               -出站: var last=arr.pop()
            2、开头出入栈：每次入栈新元素时，已入栈元素的位置都会向后顺移。
              -出站：var first=arr.shift();
      -队列：只允许从末尾进入数组，必须从开头出数组：FIFO
         -结尾入队列：arr.push();
         -开头出队列：var first=arr.shift();
二、 *二维数组：数组中的元素，又引用了另一个子数组对象
   -何时使用二维数组：2种：
      1、 只要保存横行竖列的二维数据
      2、保存上下级关系的数据时
   -如何创建二维数组：2种：
      1、先创建空数组，再赋值:
         例如： var arr=[];arr[0]=["石家庄","保定","唐山"];arr[1]=["德州","济南","烟台"];
      2、创建数组时，同时初始化子数组：     
         例如：var data=[[0,2,2,4],[2,4,4,8],[16,32,16,8],[4,2,128,4]];
   -如何访问二维数组中的数据：arr[行下标][列下标]
      比如：data中第2行，第3个元素-data[1][2]
      强调：二维数组中，行下标不能越界！
         console.log(data[1][5]); //undefined
	 console.log(data[5][1]); //
                        //undefined[1]
   -遍历二维数组：固定套路：外层循环遍历行，内存循环遍历列
      例如：
	    var arr=[[...],[...]...]
	    for(var r=0;r<arr.length;r++){
	       for(var c=0;c<arr[r].length;c++){
	       }
	    }
三、***String: 字符串：
   ***将任何数字类型转化为字符串类型，最简单的方法是加空字符串(+"")***
   -什么是字符串：多个字符组成的一个*只读*的集合(数组)
      1、凡是数组对象中不修改原对象的API，字符串都能用！
         比如：.length属性：字符个数；都可用[i]访问每个字符
         比如：slice, 

      2、凡是数组对象中，直接修改原对象的API，字符串都不能用！比如：push,  sort , splice
   -内置对象：ES标准中已经定义好的，由浏览器厂商已经实现的对象
      11个：String、Number、Boolean、Array、Date、Math、RegExp、Error、Function、Object、Global（全局）
   -包装类型：临时封装原始类型数据，提供对原始类型数据的操作方法
      -3种：String Number     Boolean(不能new)
      -何时使用包装类型：自动使用
      -为什么使用包装类型？
         原始类型的数据本来没有任何方法，当程序中使用原始类型调用方法、属性时，程序会自动创建包装类型对象封装该数据。函数调用完，包装类型自动释放
   -String API：*所有API都无法直接修改原字符串*
      1、转义字符：当字符串的内容和程序的特殊符号冲突时，或字符串中包含功能字符时，都用\转化字符的意义
         \n：换行  \t: 缩进，相当于Tab键
      2、大小写转换：将字符串中所有字符都统一转为大写或小写
         -何时使用：不区分大小写时  比如：用户名  验证码    电子邮件
         -转大写:str=str.toUpperCase();
         -转小写:str=str.toLowerCase();
      3、 获取指定位置的字符：3种：
         1、str[i];  例如：倒数第二个：str[str.length-2]
         2、str.charAt(i);-->获取指定下标处的字符
         3、str.charCodeAt(i);-->获得字符的unicode号
      4、 查找关键字的位置：2种：starti默认都是0
         1、var i=str.indexOf(kword[,starti]);从左向右,查找并输出kword首字符在字符串中的下标,如果没找到，返回-1
	    starti：从starti位置开始向后查找下一个。 如果省略starti，默认从0开始找
         2、var i=str.lastIndexOf(kword[,starti]);从starti位置开始，向左找！上一个kword
	    这个方法有一个问题：当不可能输出-1，陷入死循环，所以要手动退出
      5、获取字符串：3种
         -var subStr=str.slice(starti[,endi+1]);例如：pid.slice(6,-5+1)  //括号内的内容可省略
	 -var subStr=str.substring(starti[,endi+1])不支持负数参数  例如：pid.substring(6,pid.length-5+1);
	 -var subStr=str.substr(starti,取几个);例如：pid.substr(6,8)

js第七天
正课：
1、 ***String API：
2.、***正则表达式：

一、 ***String API:
   1、 分隔字符串：var arr=str.split("分隔符");arr中以数组形式保存每段子字符串
      何时使用：今后只要分段处理字符串时,都要先分隔再遍历
      固定套路：将字符串切割为字符数组: //Hello --var chars=str.split("");
   2、模式匹配：按照规则查找或替换字符串中的子内容
      查找：2种：
      1、只能从开始位置，找第一个匹配的关键字-- var i=str.search(/kword/i);
            何时使用：仅判断有没有关键字时
            与 str.indexOf比较:search专门用于模式匹配，indexOf不支持模式匹配
      2、 获得所有关键字的内容，或个数：
            var arr=str.match(/kword/ig);--arr中保存了所有关键字的内容
            -arr.length表示匹配的关键字的个数
            -*如果没找到，返回null*,*都要先判断是否为null，再处理！否则会出错*
            -*match无法获得关键字的下标位置！*
   ***替换：var newStr=str.replace(模式,"替换内容")
二、正则表达式：专门规定字符串中字符*格式规则*的表达式
   ***String中支持正则的API：只有split、search、match、replace这四个
   何时使用：只要定义字符串格式规则，都用正则表达式
      最简单的正则：一个关键词的原文，就是最简单的正则
   1、备选字符集：规定某*一位*字符可选的备选文字类型
      语法：[备选字符集列表]  强调：无论备选字符集中有多少字符，都只能选1个--一个[]只代表1位字符！
      比如：6位数字：[0123456789][0123456789][0123456789][0123456789][0123456789][0123456789]
      "^":表示出了xxx之外其他都行  例如[^ab]--除了ab之外其他都行
      "-":表示如果备选字符连续，可用"-"表示"到之意"  例如：[a-z]--所有的小写字母
   2、预定义字符集：专门表示常用的连续的字符集
      "\d":表示一位数字，相当于[0-9]
      "\w":表示一位数字、字母或下划线，相当于[0-9a-zA-Z_]
      "\s":表示一位空字符：空格，tab符，相当于[空字符]
       ".":表示出了换行外所有的字符
       "\d","\w","\s":表示出了"\d","\w"或"\s"外的所有字符
   3、量词：规定一个字符集出现的次数：2种发放
      -明确数量：3种：
         1、{min，max}：最少min位，最多max位
	 2、{min，}：最少min位，最多不限
	 3、{n}：必须n位
	 练习： 身份证号:\d{15}(\d{2}[0-9xX])?
	    至少15位数字-->"\d{15}"
	    2位数字-->"\d{2}"
	    最后一位数字或x X-->"[0-9xX]"
	    后三位可有可无，但最多出现1次-->"(\d{2}[0-9xX])?"
      -不确定数量：3种
         1、?:可有可无，最多一次，相当于{0,1}
	 2、*:可有可无，多了数量不限，相当于{0,}
	 3、+:最少一次，多了数量不限，相当于{1,}
         练习：手机号码：(\+86)?\s*1[34578]\d{9}
	    +86 可有可无，最多一次        --->"(\+86)?"  其中"\"代表转义之意，将符号转为符号本身的意思
	    空字符可有可无，多了数量不限  --—>"\s*"
	    数字1  --->"1"  在正则中直接写数字表示只能是该值
	    从3,4,5,7,8选一个-->"[34578]"
	    最后必须是9位数字-->"\d{9}"

js第八天
1、***RegExp
2、***String中支持正则的API：只有split、search、match、replace这四个
3、*Math
4、*Date

一、***RegExp对象：封装了正则表达式，提供了利用正则表达式执行验证和查找的API
   何时使用：只要利用正则表达式执行验证和查找功能时
   -创建：2种
      1、var reg=/正则表达式/ig;--正则表达式在运行时不会改变
      2、var reg=new RegExp("变量(正则表达式)","ig");--在运行时正则表达式可能被改变时
         强调：这种方式下的正则表达式中的"\"符号前都要再加一个"\"符号，防止js将其识别为转义字符
   -如何使用：2种操作：
      1、格式验证：var bool=reg.test(str);
         验证：要求从头到尾必须完整匹配！
	 问题：但是test方法默认只要部分匹配即可！
	 解决：都要在正则表达式前加"^"号，后加"$"
	    "^":表示以xxx开头
	    "$":表示以xxx结尾
	    "^"和"$"联用表示从头到尾必须完整匹配
	 练习：密码强度要求--6-8位密码，只能是字母，数字的组合，至少包含一位大写字母，至少包含一位数字
	    预判：
               1、不完全由小写字母或数字组成，可能包含大写或符号--(?![a-z0-9]*$)
		  解析："?":预判  "!":不等于  "*":可有可无，多了数量不限  "$":到最后，意思是所有
               2、不完全由大写字母或小写字母组成，可能包含数字或符号--(?![a-zA-Z]*$)
	          解析："?":预判  "!":不等于  "*":可有可无，多了数量不限  "$":到最后，意思是所有
               3、正则规则：只能是字母数字的组合-->屏蔽了符号--[a-zA-Z0-9]{6,8}
	    完整：^(?![a-z0-9]*$)(?![a-zA-Z]*$)[a-zA-Z0-9]{6,8}$
      2、查找API：
         语法：var arr=reg.exec(str);  在str中查找所有符合reg规定的关键字（所有要加g）
         其中：
	    arr[0]:保存了当前关键字的内容
	    arr.index:保存了当前关键字的位置
	    reg.lastIndex:保存了下次开始查找的位置(自动生成，相当于reg.lastIndex=arr.index+keyword.length)
	    注意：找不到返回null(先判断再使用)
	 何时使用：何时使用：只要即查找内容，又查找位置，只能用reg.exec
      总结：查找关键字：
         1. var i=str.search(reg)-->判断有没有    缺点：不能指定开始位置  
         2. var arr=str.match(reg)-->获得所有关键字内容，个数   缺点：不能返回位置   
         3. var i=str.indexOf("kword"[,starti])-->从指定位置开始，查找下一个关键字的位置   缺点：不支持正则
         4. var arr=reg.exec(str)-->即获得内容，又获得位置   缺点：复杂
   -正则：贪婪模式与懒惰模式
      默认贪婪模式：默认总是匹配最长的符合条件的字符串   原因：.*或.+等引起
      懒惰模式：仅匹配最短的符合条件的字符串   贪婪-->懒惰: (.*?)
   -从正则表达式匹配结果中获取子内容：2步：
      1. 正则表达式中：用()包括要获取子内容的部分
      2. 程序中,本次查找后: RegExp.$n--取*本次*匹配结果中第n个()匹配的子内容,正则中n从1开始
         **(\n):表示必须和圆括号n中的内容相等**
二、 ***String中的模式匹配API：4个
    1、查找：str.search(reg)--找不到返回-1  str.match(reg)找不到返回null;(出现null都要先判断再使用)
    2、替换：str.replace(reg,"替换值");
       固定套路：利用replace格式化数据"替换值"中，也可以使用$n属性，和RegExp.$n的用法完全相同
    3、切割：var arr=str,split(reg);
三、*Math：专门执行数学计算的对象，封装了数学计算中常用的常量
   注意：没有构造函数--不能实例化对象（即不能使用new关键字创建新的实例）
   1、取整：3种
      -上取整：只要超了就取下一个整数(进一法)   语法：Math.ceil(n);
      -下取整：只要不是整数就去掉小数取整(15.9-->15)   语法：Math.floor(n);
      -四舍五入：四舍五入法取整   语法：Math.round(n);
         注意：解决舍入误差的办法是想办法扩大小数位数的四舍五入
         Math.round(n)和toFixed()比较:
	 -toFixed():使用对象是Number对象，可以按任意小数位数，返回值是字符串
	 -Math.round():使用对象是Math对象，只能取整数，返回值是数字
   2、乘方/开平方:
      乘方：Math.pow(n,m); 表示n的m次方
      开平方：Math.sqrt(n); 表示n的平方根
   3、获取最大值、最小值；
      最大值：Math.max(a,b,c...);
      最小值：Math.min(a,b,c...);
      ***固定套路：Math.max,apply(Math,arr);-->它会变为Math.max(arr[0],...)
         用于变相获取数组中的最大值，对于获取最小值同样适用
   4、随机数：Math.random();  表示0<=n<1;
      任意min到max之间取一个随机整数：parseInt(Math.random()*(max-min)+min);
四、*Date：封装了一个时间点(1970年元旦至今的毫秒数)，提供了对时间和日期的操作API
   -Date中封装了什么？Date封装了从1970年1月1日0点0分0秒至今的毫秒数
   -创建Date对象：4种方法--date.getTime(): 获得日期对象中的毫秒数
      1、var now=new Date();//创建了一个新日期对象，同时保存了*客户端*当前时间点的毫秒数--获得当前时间
      2、自定义时间对象：var time=new Date("xxxx/xx/xx [xx:xx:xx]");--其中"/"不能更改，以便确定所有浏览器能识别
      3、自定义时间对象：var time=new Date(年,月-1,日[,时,分,秒]);//注意月份一定要-1
      4、复制日期对：用于不更改原数据时，将数据拷贝一份用于计算，原值不改动-->var date=new Date();
         var date1=new Date();
         var date2=new Date(date1.getTime());
              //new Date(毫秒数)
         date2.setXXX(date2.getXXX()+-n)
五、*Date API：
   -Date API参数在JavaScript离线手册的位置-->左侧js对象-->js日期-->中间找：JavaScript Date对象参考手册
   1、每个分量都有一对儿get/set方法
   2、方法的命名：年月日星期 都不带s，时分秒毫秒 都以s结尾
      比如：设置小时: setHours();获取月份：getMonth()  
      -特殊：
         *年: get/setFullYear()-->使用4位完整年份
         *星期: getDay()：获得星期的序号，序号如下：
             星期： 日 一 二 三 四 五 六
             序号：  0  1  2  3  4  5  6
         *星期没有set方法！
         *月中的日: get/setDate()
   3、返回值：只有月中的日从1开始到31结束，其它分量都是从0开始到进制减1结束(所以只有月份需要修正)
         月份：1月   2月   3月...11月  12月
                0     1     2     10    11 
   4、日期如何计算？2种：
      1、两日期对象直接相减，结果是毫秒差！
      2、对任意分量做加减：先用get取出来，做计算，然后再用set放回去--date.setXXX(data.getXXX()+/-n);
   5、日期转字符串输出：
      1、 date.toLocaleString(); 转为完整日期字符串
      2、 date.toLocaleDateString(); 仅转为日期部分
      3、 date.toLocaleTimeString(); 仅转为时间部分

js第九天：
1、*异常处理
2、***Function对象   ****闭包

一、*错误/异常处理
   -什么是错误：导致程序无法继续执行的异常状态--js中一旦发生错误，就会自动创建一个Error类型对象
   -js中有几种错误类型：6种
      1、SyntaxError：语法错误
      2、ReferenceError：引用错误，找不到变量或对象
      3、TypeError：类型错误，错误的使用了对象中的方法时
      4、RangeError：范围错误，参数超出范围
      5、EvalError：调用eval函数时出错
      6、URLError：URL错误
   -错误处理：在程序发生错误时，保证程序不退出或正常退出
   -如何错误处理：tryCatch快：3部分组成
      1、语法：
         try{
	    可能出错的代码段
	 }catch(参数变量err){
	    1、记录/显示错误的信息
	    2、继续向调用者抛出异常
	    //仅在发生错误时执行，且一旦发生错误err中就会自动存入err对象
	 }[finally{无论对错，一定都会执行的代码段，存放用于释放资源的代码}]//[]中的东西可有可无
      2、何时需要定义错误处理？某段只要有可能出错的代码，都要包在tryCatch块中
         建议：尽量优先使用if...else结构判断已经预知的错误，只有无法预知的错误才使用try catch
	 -tryCatch用法：
	    1、解决浏览器兼容性问题（现在越来越少用）
	    2、抛出自定义异常：throw new Error("自定义错误消息")
               比如：如果程序员甲定义了一个方法，被程序员乙调用
                     如果程序员乙错误的使用甲的方法，
                     甲的方法中就要抛出自定义错误消息
                     乙在调用时，就要将甲的方法包在try块中

二、***function对象：js中一切都是对象，连函数也是对象，函数名其实是应用函数定义对象的变量 
   1、*arguments对象：
      -重载：程序中可定义多个相同函数名，不同参数列表的函数，调用者不用区分每个参数，执行时，程序根据传入的参数个数自动选择那个函数执行
      -js语法不支持重载！但是可用arguments对象模拟重载效果
      -arguments对象：函数对象内，自动创建的专门接收所有参数值的类数组对象
         arguments[i]:获得传入的参数下标为i值
	 arguments,length:获得传入参数的长度
      ***即使定义了参数变量，arguments对象同样会收到所有参数值
   2、***函数对象本质
      1、 创建函数对象：3种：
         1、 声明方式：function 函数名(参数){函数体;return 返回值;}
            函数名和函数定义都被提前，在调用前后位置定义都行
         2、  函数直接量：var 函数名=function(参数){函数体;return 返回值; }
            仅函数名变量声明会提前， 函数定义留在本地，必须定义在调用前！
         3、 使用new创建函数类型对象：var 函数名=new Function("a","b",...,"函数体");
   3、***内存中的函数对象***
      -创建函数对象时：同时创建2个对象：
          函数对象:函数的定义
          作用域链对象：保存了函数对象可用变量的位置的对象（栈），默认第一项指向window对象
      -调用函数时：又会创建1个新对象：
             活动对象：专门保存局部变量的对象，同时在作用域链对象中追加指向活动对象的引用
      -调用后：作用域链中活动对象的引用出，活动对象因无人引用而释放
   4、***匿名函数：定义时，不指定函数名的函数
      何时使用：2大用途：
         1、匿名函数自调：定义完，立刻执行，执行完立刻释放
            何时使用：只有确定函数只执行一次时！
            如何自调：(function(参数){函数体})(参数值);其中参数值可有可无
            自调：定义在哪儿，就在哪儿执行，不提前
         2、 匿名函数回调：向将函数作为对象传递给另一个函数，由另一个函数自主决定在需要时调用
           何时使用：只要将一个函数对象传递给其他方法调用时
           如何回调：直接将匿名函数的声明传入另一个函数中。
   5、***闭包：
      -问题（闭包概念出现的原因）：变量既可以共享，长久保存，又不会全局污染
         全局变量和局部变量的存在的缺陷：
         -全局变量：容易全局污染
         -局部变量：无法共享，不能长久保存 
      -解决：3步：闭包三特点：
         1、定义外层函数，封装被保护的局部变量
         2、定义内层函数，执行对外层函数局部变量的操作
         3、外层函数返回内层函数的对象，并且外层函数被调用，结果被保存在全局变量中
      -何时使用：即反复使用局部变量，又避免全局污染，就要用闭包
      -判断闭包执行结果：
         *1、外层函数被调用几次，就有几个受保护的局部变量副本
         2、来自一个闭包的函数被调用几次，受保护的局部变量就变化几次

js第十天：
1、面向对象
   1、创建自定义对象
   2、****继承-父级子级之间的调用

一、面向对象：在程序中都是用一个对象来描述现实中一个具体的东西
   -现实中的一个东西都包含属性和功能：
      1、属性：描述一个东西特点的变量
      2、功能：东西可以执行的操作
   -面向对象三大特点：封装、继承和多态
      -封装：将描述同一个东西的属性和方法，定义在一个对象中
      -继承：父对象中的属性和方法，子对象可直接使用
     -多态：同一个对象，在不同情况下，呈现不同的状态
          重载：同一方法名，传入参数不同，执行不同的操作
          重写：子对象觉得父对象的成员不好用，可自己定义一个，覆盖父对
   -什么是对象？封装多个数据的储存空间
   -什么是自定义对象：封装现实中一个东西的属性和功能的储存空间。现实中的属性会成为对象中的属性变量，现实中东西的功能会成为对象中的方法(函数)。
   -创建自定义对象：3种方法
      1、对象直接量：var obj={属性名1:值1,属性名:值2,...}--js中一切都是对象！所有对象的底层都是hash数组
         -属性：如何访问属性:2种：obj.属性名  obj["属性名"]
         -若访问对象中不存在的属性(相当于访问数组中不存在的下标): 不会出错，返回undefined
         -强行给不存在属性赋值，不报错！js会自动创建同名属性
         -如何判断某个对象是否包含指定成员：3种
            1、 obj.hasOwnProperty("成员名") ：如果找到，返回true，否则返回false！
            2、 "属性名" in 对象：如果找到，返回true，否则返回false！
            3、 直接使用obj.属性名作为条件: 
	       arr.indexOf!==undefined：如果不包含,返回undefind-->false，如果包含,返回值或function-->true
               何时省略：判断方法是否存在时，可省略!==;如果确定属性值一定不是null,0,"",NaN，也可省略
         -方法(函数)：
            -如何在方法中，访问当前对象自己：****this关键字-运行时，指代正在*调用*方法的对象(.前的对象)
               this本质是window下唯一的一个指针，指向当前正在调用方法的对象
            -如何在方法内，访问当前对象自己的属性：this.属性名
               ***在方法内访问当前对象自己的属性，必须用this.属性名
               ***this和定义在哪儿无关！仅和调用时使用的当前对象有关
               ***如果无主的调用或赋值，默认this都是window！
      2、new关键字：var obj=new Object();//创建一个空对象
         obj.属性名=值;
	 obj.方法名=function(){...this.属性名...}
      3、利用构造函数*反复*创建*相同构造*的对象：2步
         -构造函数：描述一类对象结构的特殊函数
	 1、定义构造函数：
	    function 构造函数名/类型名(属性参数1,属性参数2，...(公共属性，可以多个)){
	       this.属性名=属性参数1;//调用构造函数时在当前正在创建的对象创建一个属性名，并复制为属性参数1的值
	       ...(几个属性参数定义几个)
	       if(!构造函数名.prototype.方法名){//防止反复常见同一个属性
	          构造函数名.prototype.方法名=function(){...this.属性名...}
	       }
	    }
	 2、使用new创建对象同时，调用构造函数：
	    var obj=new 构造函数名/类型名(属性参数1,属性参数2，...(可以多个))
	    new的功能：
	       1、创建了一个空对象：new obj={};
	       2、利用空对象，调用构造函数，构造函数在空对象中添加属性和方法
	       3、设置新对象的——proto——指向构造函数的prototype(原型)对象中
	       4、返回新对象的地址
      4、Object.create(父对象,{扩展属性的列表对象})//新方法，有浏览器兼容性问题
***this：指代当前正在调用方法的的对象，this和定义在哪儿无关，仅和调用时使用的对象有关！所有无主(不用var赋值的变量，匿名函数)都是window的***
二、 原型，原型链，继承
   -原型对象：每个函数对象都有一个原型对象，构造函数的原型对象负责保存所有子对象共享的成员！
      所有函数都有prototype，指向自己的原型对象;
      所有对象都有__proto__，指向自己父级原型对象;
      ]]]]]]]]]]]]]]]]]]]]]]]]]]]
      建议：所有子对象共享的方法，都应定义在构造函数的原型对象中。——避免重复定义方法对象，浪费内存。
      说明：其实所有内置类型的API都是定义在类型.prototype
      -扩展对象属性：2种扩展：
         1、扩展共有属性：通过构造函数.prototype添加的属性
         2、扩展自有属性：通过某一个具体子对象添加的属性
      -删除属性：delete 对象.属性名-->*仅能删除当前对象自己的属性，无法删除共有属性
	 /* 全局变量：3种：
	  var n=1; |   window.n=1;   |    window["n"]=1
	不能delete    不能delete        可被delete      */
   -原型链：所有父子级对象间由__proto__形成的多级引用关系，由各级对象的__proto__逐级继承形成的关系
      -原型相关API：
         -判断自有属性或共有属性：
            1、判断自有属性：obj.hasOwnProperty("属性名")
	    2、判断原型链上的属性：3中
	       -判断不包含：
	       if(!("属性名" in obj));--最可靠
	       if(obj.属性名===undefined);
	       if(!obj.属性名)
            3、判断共有属性：
               "属性名" in obj && ！obj.hasOwnProperty("属性名")-->在原型关系中包含 且  子对象自己*没有*
      -获得任意对象的父级原型对象：Object.getPrototypeOf(子对象);==>子对象.__proto__
      -判断父对象是否在子对象的原型链上：父对象.isPrototypeOf(子对象)
   ***检测一个对象是不是数组类型：4种
      1、Array.prototype.isPrototypeOf(obj);
      2、obj instanceof Array;//instance:实例   arry:数组
      3、obj.constructor==Array;//仅判断直接父级(constructor:构造函数)
      4、利用当前对象，强行调用原始的toString方法：
         Object.prototype.toString.call(obj)==[object Array];
   -继承：js中一切继承都是用原型对象实现的！
      -为什么要继承：代码重用，节省空间
      -直接继承对象：想方设法修改对象的__proto__：3种方法
         1、仅修改一个对象的__proto__：Object.setPrototypeOf(子对象,父对象);
	 2、通过修改构造函数的原型对象，实现批量修改后续子对象的继承关系:构造函数.prototupe=父对象;
	    强调：仅影响之后创建的对象的继承关系，之前创建的对象依然继承旧构造函数.prototype
	 3、Object.create(父对象,[{a属性列表}]);//[]里的内容可以省略
	    作用：创建一个空对象，继承父对象中得很属性，聚成同时可以再扩展属性和方法
      -仅继承结构：模拟Java中的继承
         function 父类型构造函数(属性参数1,属性参数2){
	    this.属性1=属性参数1;
            this.属性2=属性参数2;
         }
         function 子类型构造函数(属性参数1,属性参数2,属性参数3){
            父类型构造函数.call(this,属性参数1,属性参数2);
            this.属性3=属性参数3;
         }
         var obj=new 子类型构造函数(值1,值2,值3){